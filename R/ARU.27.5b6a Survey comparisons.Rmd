---
output: 
  word_document:
    reference_docx:  ../report_template_v1.5.dotx
---

```{r echo=FALSE, fig.asp=1.4, fig.align="center", message=FALSE, warning=FALSE}

# ---------------------------------------------------------------------------------------
# Argentines survey comparisons
#
# 04/02/2020 Initial coding for scottish survey
# 05/02/2020 Added Faroese surveys
# ---------------------------------------------------------------------------------------

require("knitr")
knitr::opts_chunk$set(echo = FALSE,	message = FALSE,	warning = FALSE,	comment = "",	
                      crop = TRUE , fig.width=10)
knitr::knit_hooks$set(crop = hook_pdfcrop)

rm(list=ls())

# Libraries
library(tidyverse)     # combined package of dplyr, tidyr, ggplot, readr, purrr and tibble
library(rmarkdown)     # rmarkdown functionality
library(pander)        # tables
library(lubridate)     # data handling
library(reshape2)      # reshaping data; e.g. cast
library(readxl)        # excel reader
library(writexl)       # write excel files
library(broom)         # clean up statistics
library(scales)        # pretty scales
library(stringr)       # string manipulations
library(captioner)     # captioning of figures and tables

# Source utilities
source("theme_publication.R")
# source("../../gisland/r/geo_inside.R")

# lowcase function
lowcase <- function(df) {
  names(df) <- tolower(names(df)) %>% gsub("\\?|\\s+|\\.+|_+|\\(|\\)","",.) 
  return(df) 
  }


# set paths
onedrive  <- file.path(Sys.getenv('USERPROFILE'), 'PFA/PFA team site - PRF') 

# datapath <- "//community.ices.dk/ExpertGroups/benchmarks/2020/wkdeep/2014 Meeting docs/06. Data/aru.27.5b6a"
datapath <- "D:/iWKGSS 2020/06. Data/aru.27.5b6a/Survey"

# default settings for tables
panderOptions('table.alignment.default', function(df) ifelse(sapply(df, is.numeric), 'right', 'left'))

# To number figures and tables
fig_nums <- captioner::captioner(prefix = "Figure ")
tab_nums <- captioner::captioner(prefix = "Table ")

# load spatial data
load(file.path(onedrive,"rdata/world.df.RData"))
load(file.path(onedrive,"rdata/fao.df.RData"))
load(file.path(onedrive,"rdata/icesrectangles.df.RData"))

rect <- 
  icesrectangles.df %>% 
  group_by(rect) %>% 
  filter(row_number() == 1) %>% 
  dplyr::select(rect, long, lat)

# Length-weight parameters (from Fishbase, update needed from Pamela)
lw_a <- 0.0030
lw_b <- 3.26


# load survey count data
scottish_count <- 
  read_excel(file.path(datapath, "Scottish Deepwater Survey Greater Argentine Data.xlsx"),
             sheet = "raw_data",
             col_names = TRUE,
             col_types = "text") %>% 
  lowcase() %>% 
  
  mutate_at(c("year", "haul", "duration"), list(as.integer)) %>% 
  mutate_at(c("shotlon", "shotlat", "n", "nhour"), list(as.numeric)) %>% 
  mutate(species="ARU") %>% 
  mutate(surveyname="SD")

# load survey length data
scottish_length1 <- 
  read_excel(file.path(datapath, "Scottish Deepwater Survey Greater Argentine Data.xlsx"),
             sheet = "N@L_1998-2012",
             col_names = TRUE,
             col_types = "text") %>% 
  lowcase() %>% 
  
  mutate_at(c("year", "haul", "duration","length"), list(as.integer)) %>% 
  mutate_at(c("shotlon", "shotlat", "n", "nhour"), list(as.numeric)) %>% 
  mutate(species="ARU") %>%
  # convert to kg
  mutate(kghour = nhour * lw_a * (length^lw_b) /1000)

scottish_length2 <- 
  read_excel(file.path(datapath, "Scottish Deepwater Survey Greater Argentine Data.xlsx"),
             sheet = "N@L_2013-2019",
             col_names = TRUE,
             col_types = "text") %>% 
  lowcase() %>% 
  rename(n=measurednumber, nhour=raisednumber) %>% 
  
  mutate_at(c("year", "haul", "length"), list(as.integer)) %>% 
  mutate_at(c("n", "nhour"), list(as.numeric)) %>% 
  mutate(species="ARU") %>%
  mutate(length = length/10) %>% 
  
  # convert to kg
  mutate(kghour = nhour * lw_a * (length^lw_b) /1000) %>% 
  
  # merge haul data
  left_join(dplyr::select(scottish_count, cruise, haul, shotlon, shotlat, depth), 
            by=c("cruise","haul")) %>% 
  mutate(shotlat = ifelse(is.na(shotlat), 57, shotlat),
         shotlon = ifelse(is.na(shotlon), -4, shotlon))

scottish_length <-
  bind_rows(scottish_length1, scottish_length2) %>% 
  dplyr::select(year, cruise, haul, species, shotlon, shotlat, depth, n, nhour, kghour) %>% 
  mutate(surveyname="SD")

# Faroese summer
faroe_summer <- 
  read_excel(file.path(datapath, "FaroeseSummerSurvey_kg_haul_1996-2019.xlsx"),
             sheet = "Sheet1",
             col_names = TRUE,
             col_types = "text") %>% 
  lowcase() %>% 
  rename(shotlat=puntlat, shotlon = puntlon,
         kghour=catchkg) %>% 
  
  mutate_at(c("year"), list(as.integer)) %>% 
  mutate_at(c("shotlat","shotlon", "kghour"), list(as.numeric)) %>% 
  mutate(species="ARU") %>% 
  mutate(surveyname="FS")

# Faroese summer
faroe_deepwater <- 
  read_excel(file.path(datapath, "FaroeseDeepwaterSurvey_kg_haul_2014-2019.xlsx"),
             sheet = "Sheet1",
             col_names = TRUE,
             col_types = "text") %>% 
  lowcase() %>% 
  rename(shotlat=y1, shotlon = x1,
         kghour=catchkg) %>% 
  
  mutate_at(c("year"), list(as.integer)) %>% 
  mutate_at(c("shotlat","shotlon", "kghour"), list(as.numeric)) %>% 
  mutate(species="ARU") %>% 
  mutate(surveyname="FD")

```

**Scottish deepwater survey**

M.A. Pastoors

`r format(Sys.time(), '%d/%m/%Y')`


**Abstract**


<!--1. Introduction ------------------------------------------------------ -->

# Introduction


<!--2. Material and methods ------------------------------------------------------ -->

# Material and methods


**Plots of survey**

```{r echo=FALSE,  fig.asp=1.4, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(name    = "survey map", 
         caption = "Distribution of hauls with argentines",
         display = FALSE)

# number of vessels

scottish_count %>%

  ggplot(aes(x=shotlon, y=shotlat)) +
  theme_publication() +
  theme(axis.title       = element_blank(), 
        text             = element_text(size=12),
        # legend.position  = "none", 
        legend.key.width = unit(1, "cm"),
        legend.key.size  = unit(2, "cm"),
        panel.spacing    = unit(0.1, "lines") ) +  
  
  coord_quickmap(xlim=c(-15,0) , ylim=c(54,60)) +
  geom_polygon(data=world.df, aes(long,lat,group=group), 
               fill="cornsilk", size=0.25,color="gray15", alpha=0.7) +
  
  geom_point(aes(size=nhour, colour=as.factor(species)), alpha=0.5) +
  
  labs(title="Argentines n/hour") +
  facet_wrap(~year, ncol=5)

scottish_length %>%
  group_by(surveyname, year, haul, species, shotlon, shotlat) %>% 
  summarize(nhour=sum(nhour, na.rm=TRUE),
            kghour = sum(kghour, na.rm=TRUE)) %>% 
  # bind_rows(faroe_summer) %>% 
  bind_rows(faroe_deepwater) %>% 
  
  filter(year > 2010) %>% 
  filter(kghour > 0) %>% 
  
  ggplot(aes(x=shotlon, y=shotlat)) +
  theme_publication() +
  theme(axis.title       = element_blank(), 
        text             = element_text(size=12),
        # legend.position  = "none", 
        legend.key.width = unit(1, "cm"),
        legend.key.size  = unit(2, "cm"),
        panel.spacing    = unit(0.1, "lines") ) +  
  
  coord_quickmap(xlim=c(-15,0) , ylim=c(54,64)) +
  # coord_quickmap(xlim=c(-10,02) , ylim=c(59,63)) +
  
  geom_polygon(data=world.df, aes(long,lat,group=group), 
               fill="cornsilk", size=0.25,color="gray15", alpha=0.7) +
  
  geom_point(aes(size=kghour, colour=as.factor(surveyname)), alpha=0.5) +
  
  labs(title="Argentines kg/hour") +
  facet_wrap(~year, ncol=5)
  

```

*`r tab_nums("nvessels")`*


```{r echo=FALSE, fig.asp=1.0, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(name    = "allhaulpositions", 
         caption = "Haul positions where argentines has been caught (all years combined)",
         display = FALSE)

invisible(gc())


# cjm_byhour %>% filter(shootlat > -20) %>% View()


```

*`r fig_nums("allhaulpositions")`*




##### page break

**Haul positions by contracting party and year**

The yearly postions of Argentines fishery of the offshore fleets. 

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(name    = "haulpositionsbyyear", 
         caption = "Haul positions where Jack mackerel has been caught (by year). Colours indicate the different fleets", display = FALSE)

invisible(gc())

cjm_byhour %>% 
  # offshore_all %>% 
  # filter(species == "CJM") %>% 
  filter(!is.na(shootlon) | !is.na(shootlat)) %>% 
  filter(!is.na(year)) %>% 

  ggplot(aes(x=shootlon, y=shootlat)) +
  theme_publication() +
  theme(axis.title       = element_blank(), 
        text             = element_text(size=12),
        legend.key.width = unit(1, "cm"),
        panel.spacing    = unit(0.1, "lines") ) +  
  
  coord_quickmap(xlim=c(-120,-50) , ylim=c(-50,-10)) +
  geom_polygon(data=world.df, aes(long,lat,group=group), 
               fill="cornsilk", size=0.25,color="gray15", alpha=0.7) +
  
  geom_point(aes(colour=vesselcp), size=0.8, alpha=0.5) +
  
  ggtitle("CJM haul positions by year") +
  facet_wrap(~year, ncol=3)
  # facet_grid(rows=vars(vesselcp), cols= vars(year), drop=FALSE)

```

*`r fig_nums("haulpositionsbyyear")`*




##### page break

**Mean catch per day of jack mackerel per one degree longitude and 1/2 degree latitude**

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "catchperdayperrect", 
  caption = "Catch per day (tonnes) of Jack mackerel (summed by 1 degree longitude and 0.5 degree latitude)",
  display = FALSE)

invisible(gc())

t <- 
  cjm_byday %>% 
  # offshore_all %>% 
  # filter(species == "CJM") %>% 
  filter(!is.na(shootlon) & !is.na(shootlat)) %>% 
  filter(!is.na(year)) %>% 
  
  mutate(rect = encode_zchords(x=shootlon, y=shootlat, dx = 1, dy = 0.5) ) %>% 

  group_by(vesselcode2, year, day, rect) %>% 
  summarise(catch  = sum(catch, na.rm=TRUE)) %>% 
  group_by(year, rect) %>% 
  summarise(catch  = mean(catch, na.rm=TRUE)) %>% 
  separate(rect, c("shootlon", "shootlat"), sep = ":", convert = TRUE, remove = FALSE) %>% 
  
  ungroup()

b <- 
  log_breaks(n=7)(c(1,max(dplyr::select(t, catch), na.rm=TRUE))) 

td <-
  t %>% 
  mutate(catch = cut(catch,breaks=b, include.lowest=T, dig.lab=10) ) %>% 
  filter(!is.na(catch))

td %>% 
  
  ggplot(aes(x=shootlon, y=shootlat)) +
  theme_publication() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        text             = element_text(size=12),
        legend.key.width = unit(1, "cm"),
        panel.spacing    = unit(0.1, "lines") ) +  
  
  coord_quickmap(xlim=c(-120,-50) , ylim=c(-50,-10)) +
  geom_polygon(data=fao.df, aes(long, lat, group=group), 
               fill = NA, size=0.25, color="gray60", alpha=0.3) +
  geom_polygon(data=world.df, aes(long,lat,group=group), 
               fill="cornsilk", size=0.25,color="gray15", alpha=0.7) +
  geom_tile(aes(shootlon, shootlat, fill = catch), colour=NA, alpha=1.0) +
  scale_fill_brewer(palette = "YlOrRd") + 
  labs(x = NULL, y = NULL) +
  ggtitle("Jack mackerel catch by day and square") +
  facet_wrap(~year, drop=FALSE, ncol=4)

# filter(td, is.na(year)) %>% View()

```

*`r fig_nums("catchperdayperrect")`*




##### page break

**Jack mackerel log CPUE by day against latitude and longitude**

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "lcpuelatlon", 
  caption = "Log catch per day (tonnes) of Jack mackerel against latitude (top) and longitude (bottom).",
  display = FALSE)

cjm_byday %>% 
  # filter(shootlat <= -24) %>% 
  
  ggplot(aes(shootlat, lcpue) ) +
  theme_publication() +
  theme(legend.position="none") +
  geom_point(aes(colour = vesselcp), alpha=0.5) 


cjm_byday %>% 

  ggplot(aes(shootlon, lcpue) ) +
  theme_publication() +
  # theme(legend.position="none") +
  geom_point(aes(colour = vesselcp), alpha=0.5) 


```

*`r fig_nums("lcpuelatlon")`*




##### page break

**Comparison of different CPUE metrics: by hour, by day and by week**

Average CPUE by year and contracting party has been calculated by hour, by day and by week. Each of the series has been scaled to the maximum of the time series. This indicates that the nominal CPUE by day and by week give the same overall pattern which is differing from the CPUE by hour. 

```{r echo=FALSE, fig.asp=1.0, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "comparecpuemetrics", 
  caption = "Jack mackerel CPUE metrics by hour, by day and by week, scaled to the maximum of the time series.",
  display = FALSE)

# CPUE per day averaged by year
byhour <-
  cjm_byhour %>% 
  group_by(vesselcp, year) %>% 
  summarize(
    catch_byhour  = mean(catch, na.rm=TRUE),
    cpue_byhour   = mean(cpue, na.rm=TRUE),
    effort_byhour = mean(effort, na.rm=TRUE)) %>% 
  group_by(vesselcp) %>% 
  mutate(
    catch_byhour = catch_byhour/max(catch_byhour, na.rm=TRUE),
    cpue_byhour = cpue_byhour/max(cpue_byhour, na.rm=TRUE),
    effort_byhour = effort_byhour/max(effort_byhour, na.rm=TRUE))

byday <-
  cjm_byday %>% 
  group_by(vesselcp, year) %>% 
  summarize(
    catch_byday  = mean(catch, na.rm=TRUE),
    cpue_byday   = mean(cpue, na.rm=TRUE),
    effort_byday = mean(effort, na.rm=TRUE)) %>% 
  group_by(vesselcp) %>% 
  mutate(
    catch_byday = catch_byday/max(catch_byday, na.rm=TRUE),
    cpue_byday = cpue_byday/max(cpue_byday, na.rm=TRUE),
    effort_byday = effort_byday/max(effort_byday, na.rm=TRUE))

byweek <-
  cjm_byweek %>% 
  group_by(vesselcp, year) %>% 
  summarize(
    catch_byweek  = mean(catch, na.rm=TRUE),
    cpue_byweek   = mean(cpue, na.rm=TRUE),
    effort_byweek = mean(effort, na.rm=TRUE)) %>% 
  group_by(vesselcp) %>% 
  mutate(
    catch_byweek = catch_byweek/max(catch_byweek, na.rm=TRUE),
    cpue_byweek = cpue_byweek/max(cpue_byweek, na.rm=TRUE),
    effort_byweek = effort_byweek/max(effort_byweek, na.rm=TRUE))

my.print <- "cpue"

bind_rows(byhour, byday, byweek) %>% 
  gather(key=metric, value=value, catch_byhour:effort_byweek) %>% 
  
  filter(grepl(my.print, metric)) %>% 
  
  mutate(year = as.numeric(as.character(year))) %>% 

  ggplot(aes(x=year, y=value, group=metric)) +
  theme_publication() +
  theme(axis.title       = element_blank(), 
        text             = element_text(size=12),
        legend.key.width = unit(1, "cm"),
        legend.key.size  = unit(2, "cm"),
        panel.spacing    = unit(0.1, "lines") ) +  
  
  geom_point(aes(colour=metric), size=2, alpha=0.5) +
  geom_path(aes(colour=metric)) +
  
  ggtitle(paste0(my.print, " metrics (scaled to maximum)")) +
  facet_wrap(~vesselcp, scales="free_y") +
  scale_x_continuous(breaks=seq(fy, ly, by = 5)) +
  expand_limits(y=0)


```

*`r fig_nums("comparecpuemetrics")`*




##### page break

**Jack mackerel Log CPUE by week and yearly average Log CPUE**

The plot below shows the distributions of log CPUE by week and by contracting party. Log CPUE was calculated as the log of catch per week divided by the number of fishing days per week. The average log CPUE is drawn as a dashed black line.  

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "lcpuebyweek", 
  caption = "Jack mackerel log CPUE (log(catch / ndays)) by week.",
  display = FALSE)

invisible(gc())

m <-
  cjm_byweek %>% 
  group_by(vesselcp, year) %>%
  summarise(lcatch   = mean(lcpue, na.rm=TRUE), 
            week     = mean(week, na.rm=TRUE)) %>% 
  mutate(date = as.numeric(as.character(year)) + week/52) %>% 
  data.frame() 

cjm_byweek %>%
  mutate(date   = as.numeric(as.character(year)) + week/52,
         lcatch = lcpue) %>%

  # mutate(date   = as.numeric(as.character(year)) + week/52,
  #        lcatch = log(catch + 0.1)) %>%
  
  ggplot(aes(date, lcatch)) +
  theme_publication() +
  # theme(legend.position="none")+
  geom_jitter(aes(colour=vesselcp)) +
  geom_line(data=m, aes(date, lcatch), colour="gray20", linetype="dashed", size=1) +
  geom_point(data=m, aes(date, lcatch)) +
  scale_x_continuous(breaks=seq(fy, ly, by = 2)) +
  facet_wrap(~vesselcp)

```

*`r fig_nums("lcpuebyweek")`*



##### page break

**El Nino effect and Humbold_current index**

It has been hypothesized that the catch rate of jack mackerel by area and season could be dependent on the climatic situation, characterized by El Nino events (NOAA,  https://www.esrl.noaa.gov/psd/data/correlation/oni.data) or the Humboldt Current Index (http://www.bluewater.cl/HCI/)

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "elnino", 
  caption = "El Nino temperature anomaly (blue line) and ELE indicator (red line). Humboldt Current Index (green line)",
  display = FALSE)

invisible(gc())

elnino %>% 
  left_join(hci, by=c("year","month")) %>% 
  mutate(date = year + (month-1)/12) %>% 
  filter(year >= fy & year <= ly) %>% 
  
  ggplot(aes(date, sst) ) +
  theme_publication() +
  # theme(legend.position="none") +
  geom_point(alpha=0.5, colour="blue") +
  geom_line(colour="blue") +
  geom_line(aes(y=ELE), colour="red") +
  
  geom_point(aes(y=hci), alpha=0.5, colour="green") +
  geom_line(aes(y=hci), colour="green") +
  geom_smooth(aes(y=hci), colour="green", span=0.2, se=FALSE) +
  
  scale_x_continuous(breaks = seq(fy, ly, by = 5)) 


```

*`r fig_nums("elnino")`*


**Modelling approach**

The general modelling approach has been to use GAM models to assess the dependency on the weekly catch of jack mackerel on different variables. In the first instance a test has been carried out to apply a negative binomial distribution to the weekly catch data

The basic model consists of catch (per week) as the main variable, the year effect (as factor) as the main explanatory variable and the log of effort as the offset (the log is taken because of the log-link function). Then the other potential explanatory variables are explored (month, vessel, contracting party, sea surface temperature anomaly, el nino effect and interaction between lat and long). Based on the AIC criteria, the best fitting second, third etc. variable have been selected. 

A leave-one-out analysis was carried out to assess the year trends in CPUE if the data from one of the contracting parties was left out. In addition, an analysis was performed using data of one contracting party only.  

<!--3. Results ------------------------------------------------------ -->

# Results

**Negative binomial distribution of catch by week**

The catch per week data fits closely to a negative binomial distribution. 

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "negbinom", 
  caption = "Fitting a negative binomial distribution through the catch data",
  display = FALSE)

# Plot the catch data distribution as a histogram and fit a negative binomial through it. 
# Data is clearly overdispersed!

fit.params  <- fitdistr(round(cjm_byweek$catch), "Negative Binomial")
res         <- hist(cjm_byweek$catch,breaks=100, plot=FALSE)
df          <- data.frame(res$density, res$mids) %>% 
  mutate(fit = dnbinom(res.mids, size=fit.params$estimate["size"], mu=fit.params$estimate["mu"]))

ggplot(df, aes(res.mids, res.density)) +
  theme_publication() +
  geom_bar(stat="identity", fill=NA, colour="black") +
  geom_line(aes(y=fit), colour="red") +
  labs(x="catch", y="density")


```

*`r fig_nums("negbinom")`*


<!-- first linear factor ------------------------------------------------------ -->

##### page break

**Modelling the first linear effect next to the year trend**

The basic model consists of catch (per week) as the main variable, the year effect (as factor) as the main explanatory variable and the log of effort as the offset (the log is taken because of the log-link function). Then the other potential explanatory variables are explored (month, vessel, contracting party, sea surface temperature anomaly, el nino effect and interaction between lat and long). 

Based on the AIC criteria,  the best fitting first linear effect was the vesselcode. 

*Catch ~ offset(log(effort)) + year + first linear effect*

```{r echo=FALSE, fig.asp=0.6, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "firstfactor", 
  caption = "Negative binomial GLM with best fitting first linear effect",
  display = FALSE)

#- Select the first linear effect next to the year effect

store <- list()
for(iVar in c("month","ELE","lonlat","vesselcp","vesselcode2","sst", "hci")){
  # print(iVar)
  form       <- formula(paste("catch ~ year + offset(log(effort)) +",iVar))
  if(iVar == "lonlat")
    form     <- formula(paste("catch ~ year + offset(log(effort)) + shootlon*shootlat"))
  # print(form)
  store[[iVar]] <- glm.nb(form,data=cjm_byweek)
}

AIC <- 
  as.data.frame((do.call(rbind,lapply(store,AIC))[,1])) %>% 
  bind_cols(var = rownames(.)) %>% 
  setNames(c("aic","var")) %>% 
  arrange((aic)) %>% 
  mutate(var = factor(var, var))  # this is the way to set the factor to the desired sequence

# plot AIC
ggplot(AIC, aes(x=var, y=aic)) + theme_publication() + geom_point(size=3)

# plot diagnostics
par(mfrow=c(2,2)); gam.check(store[["vesselcode2"]])

```

*`r fig_nums("firstfactor")`*

##### page break

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "firstfactor", 
  caption = "ANOVA results for negative binomial GLM with best fitting first linear effect",
  display = FALSE)

# print ANOVA table
anova(store[["vesselcode2"]])

```
*`r tab_nums("firstfactor")`*






<!-- Second linear factor ------------------------------------------------------ -->

##### page break

**Modelling the second linear effect next to the year and vessel effect**

*Catch ~ offset(log(effort)) + year + vessel + second linear effect*

Based on the AIC criteria,  the best fitting second linear effect was the month. 

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "secondfactor", 
  caption = "Negative binomial GLM with best fitting second linear effect",
  display = FALSE)

#- Select the second linear effect next to the year effect

store <- list()

for(iVar in c("month","ELE","lonlat","vesselcp","sst", "hci")){
  form       <- formula(paste("catch ~ year + vesselcode2 + offset(log(effort)) +",iVar))
  if(iVar == "lonlat")
    form     <- formula(paste("catch ~ year + vesselcode2 + offset(log(effort)) + shootlon*shootlat"))
  store[[iVar]] <- glm.nb(form,data=cjm_byweek)
}

AIC <- (as.data.frame((do.call(rbind,lapply(store,AIC))[,1]))) %>% 
  bind_cols(var = rownames(.)) %>% 
  setNames(c("aic","var")) %>% 
  arrange((aic)) %>% 
  mutate(var = factor(var, var))  # this is the way to set the factor to the desired sequence


# plot AIC
ggplot(AIC, aes(x=var, y=aic)) + theme_publication() + geom_point(size=3)

# plot diagnostics
par(mfrow=c(2,2)); gam.check(store[["month"]])
```

*`r fig_nums("secondfactor")`*

##### page break

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "secondfactor", 
  caption = "ANOVA results for negative binomial GLM with best fitting second linear effect",
  display = FALSE)

# print ANOVA table
anova(store[["month"]])

```
*`r tab_nums("secondfactor")`*



<!-- third linear factor ------------------------------------------------------ -->

##### page break

**Modelling the third linear effect next to the year, vessel and month effect**

*Catch ~ offset(log(effort)) + year + vessel + month + third linear effect*

Based on the AIC criteria,  the best fitting first linear effect was the combination of latitude and longitude.  

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "thirdfactor", 
  caption = "Negative binomial GLM with best fitting third linear effect",
  display = FALSE)


#- Select the third linear effect next to the year and vessel and month effect

store <- list()
for(iVar in c("ELE","lonlat","vesselcp","sst","hci")){
  form       <- formula(paste("catch ~ year + month + vesselcode2 + offset(log(effort)) +",iVar))
  if(iVar == "lonlat")
    form     <- formula(paste("catch ~ year + month + vesselcode2 + offset(log(effort)) + shootlon*shootlat"))
  store[[iVar]] <- glm.nb(form,data=cjm_byweek)
}

AIC <- (as.data.frame((do.call(rbind,lapply(store,AIC))[,1]))) %>% 
  bind_cols(var = rownames(.)) %>% 
  setNames(c("aic","var")) %>% 
  arrange((aic)) %>% 
  mutate(var = factor(var, var))  # this is the way to set the factor to the desired sequence


# plot AIC
ggplot(AIC, aes(x=var, y=aic)) + theme_publication() + geom_point(size=3)

# plot diagnostics
par(mfrow=c(2,2)); gam.check(store[["lonlat"]])

```

*`r fig_nums("thirdfactor")`*

##### page break

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "thirdfactor", 
  caption = "ANOVA results for negative binomial GLM with best fitting third linear effect",
  display = FALSE)

# print ANOVA table
anova(store[["lonlat"]])

```
*`r tab_nums("thirdfactor")`*



<!-- El nino effects ------------------------------------------------------ -->

##### page break

**Exploring the El Nino effects**

*Catch ~ offset(log(effort)) + year + vessel + month + lat-lon + 'El Nino' or Humboldt Current Index*

The El Nino effect can be taken in as the sea surface temperature (SST) anomaly or as the El Nino indicator ELE (-1, 0, 1). The Humboldt Current index HCI is taken as the pressure difference between Easter island and Antofagasta. 

The only significant effect that resulted from this analysis is the El Nino Index ELE, which will be taken up in the final model formulation. 

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

#- Explore the el nino effects

store <- list()
for(iVar in c("ELE","sst", "hci")){
  form          <- formula(paste("catch ~ year + month + vesselcode2 + shootlon*shootlat +
                                  offset(log(effort)) +",iVar))
  store[[iVar]] <- glm.nb(form,data=cjm_byweek)
}

AIC <- (as.data.frame((do.call(rbind,lapply(store,AIC))[,1]))) %>% 
  bind_cols(var = rownames(.)) %>% 
  setNames(c("aic","var")) %>% 
  arrange((aic)) %>% 
  mutate(var = factor(var, var))  # this is the way to set the factor to the desired sequence



```

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "ELEfactor", 
  caption = "ANOVA results for negative binomial GLM including the El Nino Effect ELE",
  display = FALSE)

# print ANOVA table
anova(store[["ELE"]])

```
*`r tab_nums("ELEfactor")`*

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "SSTfactor", 
  caption = "ANOVA results for negative binomial GLM including the Sea Surface Temperature (SST) anomaly",
  display = FALSE)

# print ANOVA tables
anova(store[["sst"]])
```

*`r tab_nums("SSTfactor")`*

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "HCIfactor", 
  caption = "ANOVA results for negative binomial GLM including the Humboldt Current Index HCI",
  display = FALSE)

# print ANOVA tables
anova(store[["hci"]])

```

*`r tab_nums("HCIfactor")`*





<!-- Comparing GLM and GAM with different spatial-year smoothers --------------------------------- -->

##### page break

*Modelling the spatial and year smoothers*

In this section we explore the added benefits of using the interaction between lat, long and year and whether the smoothers available in GAM provide additional benefits over GLMs. Four different models are compared. 

```{r echo=FALSE, fig.asp=0.6, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "aicglmgam", 
  caption = "AIC comparison of GLM and GAM models with different spatial and year smoothers",
  display = FALSE)

#----------------------------
#- Start adding spatial and yearly smoothers
#----------------------------

formglm <- 
  formula(paste("catch ~ year + month + vesselcode2 + shootlon*shootlat + ELE + offset(log(effort))"))
formglmy<- 
  formula(paste("catch ~ year + month + vesselcode2 + shootlon*shootlat*year + ELE + offset(log(effort))"))
formgam    <- 
  formula(paste("catch ~ year + month + vesselcode2 + s(shootlon,shootlat) + ELE + offset(log(effort))"))
formgamy   <- 
  formula(paste("catch ~ year + month + vesselcode2 + s(shootlon,shootlat,by=year) + ELE + offset(log(effort))"))

store    <- list()
store[["formglm"]] <- glm.nb(formglm, data=cjm_byweek)
store[["formglmy"]]<- glm.nb(formglmy,data=cjm_byweek)
store[["formgam"]]    <- gam(formgam, data=cjm_byweek,
                             family = negbin(glm.nb(formglm,data=cjm_byweek)$theta))
store[["formgamy"]]   <- gam(formgamy, data=cjm_byweek,
                             family = negbin(glm.nb(formglmy,data=cjm_byweek)$theta))

AIC <- (as.data.frame((do.call(rbind,lapply(store,AIC))[,1]))) %>% 
  bind_cols(var = rownames(.)) %>% 
  setNames(c("aic","var")) %>% 
  arrange((aic)) %>% 
  mutate(var = factor(var, var))  # this is the way to set the factor to the desired sequence

# plot AIC
ggplot(AIC, aes(x=var, y=aic)) + theme_publication() + geom_point(size=3)



```
*`r fig_nums("aicglmgam")`*


```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "formglm", 
  caption = "ANOVA results with negative binomial GLM including interaction lat*lon",
  display = FALSE)

# print ANOVA tables
anova(store[["formglm"]])

```

*`r tab_nums("formglm")`*


```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "formglmy", 
  caption = "ANOVA results with negative binomial GLM including interaction lat*lon*year",
  display = FALSE)

# print ANOVA tables
anova(store[["formglmy"]])

```

*`r tab_nums("formglmy")`*



```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "formgam", 
  caption = "ANOVA results with GAM including smoothing interaction s(lat*lon)",
  display = FALSE)

# print ANOVA tables
anova(store[["formgam"]])

```

*`r tab_nums("formgam")`*



```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "formgamy", 
  caption = "ANOVA results with GAM including smoothing interaction s(lat*lon*year)",
  display = FALSE)

# print ANOVA tables
anova(store[["formgamy"]])

# print(plot.gamViz(store[["formgamy"]]), pages=1)

```

*`r tab_nums("formgamy")`*


<!-- final model ------------------------------------------------------ -->

##### page break

**Final model**

Although the GLM and GAM models that included interaction between lat-long and year performed best (lowest AICs), they have not been selected as the final model as the interpretation of the year effect in the model becomes more problematic while this is the essential output of the model. Therefore, the GAM model without interaction between space and year has been selected. The final model was selected as the following model:

*Catch ~ offset(log(effort)) + year + vessel + month + s(lat-lon) + ELE*

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "finalmodeleffects", 
  caption = "Jack mackerel Final GAM model estimates for selected effects",
  display = FALSE)

final     <- formula(paste("catch ~ year + vesselcode2 + month + s(shootlon,shootlat) + ELE +
                           offset(log(effort))"))

newdat    <- expand.grid(
  year        = as.factor(fy:ly),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek$year,cjm_byweek$vesselcode2)))))[1],
                         effort=7)

finalMod  <- gam(final, data=cjm_byweek,
                 family=negbin(glm.nb(formglm,data=cjm_byweek)$theta))

# plot the estimates of the different effects
plot.gam(finalMod, all.terms=T, page=1)
plot.gamViz(finalMod, select=1)

# print(plot.gamViz(finalMod, allTerms = TRUE), pages=1)
# t <- plot.gamViz(finalMod, allTerms = TRUE)
# t1 <- plot.gamViz(finalMod, allTerms = TRUE)$plots[1]
# t2 <- plot.gamViz(finalMod, allTerms = TRUE)$plots[2]
# t3 <- plot.gamViz(finalMod, allTerms = TRUE)$plots[3]
# t4 <- plot.gamViz(finalMod, allTerms = TRUE)$plots[4]
# t5 <- plot.gamViz(finalMod, allTerms = TRUE)$plots[5]






```

*`r fig_nums("finalmodeleffects")`*



```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "cpueindexplot", 
  caption = "GAM standardized offshore fleet CPUE for jack mackerel",
  display = FALSE)

# calculate the predicted values and confidence intervals
pred      <- predict(finalMod,newdat,se.fit=T,type="link")
upr       <- exp(pred$fit + (1.96 * pred$se.fit))
lwr       <- exp(pred$fit - (1.96 * pred$se.fit))

# create df
df        <- data.frame(
               cpue = exp(pred$fit),
               upr  = upr, 
               lwr  = lwr,
               year = fy:ly,
               type = "standardized",
               stringsAsFactors = FALSE) 

ggplot(df, aes(year)) +
  theme_publication() +
  geom_ribbon(aes(ymin=lwr, ymax=upr, fill=type), alpha=0.2) +
  geom_line(aes(y=cpue, colour=type), size=1) +
  expand_limits(y=0) +
  labs(y="cpue") +
  facet_wrap(~type, scales = "free_y")


```

*`r fig_nums("cpueindexplot")`*



```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "anovafinalmod", 
  caption = "ANOVA results with final model GAM",
  display = FALSE)

# print ANOVA tables
anova(finalMod)

# print(plot.gamViz(store[["formgamy"]]), pages=1)

```

*`r tab_nums("anovafinalmod")`*


```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

tab_nums(
  name    = "cpueindextable", 
  caption = "GAM standardized offshore fleet CPUE for jack mackerel",
  display = FALSE)

df %>% 
  filter(type == "standardized") %>% 
  mutate_at(c("cpue","upr","lwr"), funs(as.integer)) %>% 
  dplyr::select(year, cpue, lwr, upr) %>% 
  print(row.names=FALSE)

# save to csv
df %>% 
  filter(type=="standardized") %>% 
  mutate(assessmentyear = ay) %>% 
  write.csv(file=paste0("Offshore fleet standardized CPUE ",fy,"-",ly,".csv"), row.names = FALSE)

```

*`r tab_nums("cpueindextable")`*


<!-- leave one out analysis ------------------------------------------------------ -->

##### page break

**leave one out analysis**

The leave-one-out analysis shows that the signal of standardized CPUE is largely similar if data of one of the contracting parties is left out. 

```{r echo=FALSE, fig.asp=1.05, fig.align="center", message=FALSE, warning=FALSE}

fig_nums(
  name    = "leaveoneout", 
  caption = "Jack mackerel leave-one-out analysis (leaving out one of the fleets)",
  display = FALSE)

cjm_byweek_noEU  <- filter(cjm_byweek, vesselcp != "EU" )
cjm_byweek_noKOR <- filter(cjm_byweek, vesselcp != "KOR" )
cjm_byweek_noVUT <- filter(cjm_byweek, vesselcp != "VUT" )
cjm_byweek_noRUS <- filter(cjm_byweek, vesselcp != "RUS" )
cjm_byweek_noCHN <- filter(cjm_byweek, vesselcp != "CHN" )

finalMod_noEU  <- gam(final,
                      data=cjm_byweek_noEU,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_noEU)$theta))
finalMod_noKOR <- gam(final,
                      data=cjm_byweek_noKOR,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_noKOR)$theta))
finalMod_noVUT <- gam(final,
                      data=cjm_byweek_noVUT,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_noVUT)$theta))

finalMod_noRUS <- gam(final,
                      data=cjm_byweek_noRUS,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_noRUS)$theta))

finalMod_noCHN <- gam(final,
                      data=cjm_byweek_noCHN,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_noCHN)$theta))

newdat_noEU <- expand.grid(
  year        = as.factor(min(as.numeric(as.character(cjm_byweek_noEU$year))):
                          max(as.numeric(as.character(cjm_byweek_noEU$year)))),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_noEU$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_noEU$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_noEU$year,cjm_byweek_noEU$vesselcode2)))))[1],
                         effort=7)

newdat_noKOR    <- expand.grid(
  year        = as.factor(min(as.numeric(as.character(cjm_byweek_noKOR$year))):
                          max(as.numeric(as.character(cjm_byweek_noKOR$year)))),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_noKOR$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_noKOR$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_noKOR$year,cjm_byweek_noKOR$vesselcode2)))))[1],
                         effort=7)

newdat_noVUT    <- expand.grid(
  year        = as.factor(min(as.numeric(as.character(cjm_byweek_noVUT$year))):
                          max(as.numeric(as.character(cjm_byweek_noVUT$year)))),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_noVUT$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_noVUT$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_noVUT$year,cjm_byweek_noVUT$vesselcode2)))))[1],
                         effort=7)

newdat_noRUS    <- expand.grid(
  year        = as.factor(min(as.numeric(as.character(cjm_byweek_noRUS$year))):
                          max(as.numeric(as.character(cjm_byweek_noRUS$year)))),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_noRUS$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_noRUS$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_noRUS$year,cjm_byweek_noRUS$vesselcode2)))))[1],
                         effort=7)

newdat_noCHN    <- expand.grid(
  year        = as.factor(min(as.numeric(as.character(cjm_byweek_noCHN$year))):
                          max(as.numeric(as.character(cjm_byweek_noCHN$year)))),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_noCHN$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_noCHN$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_noCHN$year,cjm_byweek_noCHN$vesselcode2)))))[1],
                         effort=7)

# calculate the predicted values and confidence intervals
pred_noEU       <- predict(finalMod_noEU ,newdat_noEU,se.fit=T,type="link")
pred_noKOR      <- predict(finalMod_noKOR,newdat_noKOR,se.fit=T,type="link")
pred_noVUT      <- predict(finalMod_noVUT,newdat_noVUT,se.fit=T,type="link")
pred_noRUS      <- predict(finalMod_noRUS,newdat_noRUS,se.fit=T,type="link")
pred_noCHN      <- predict(finalMod_noCHN,newdat_noCHN,se.fit=T,type="link")

# create df
df    <- data.frame(
               cpue = exp(pred_noEU$fit),
               upr  = exp(pred_noEU$fit + (1.96 * pred_noEU$se.fit)), 
               lwr  = exp(pred_noEU$fit - (1.96 * pred_noEU$se.fit)),
               year = min(as.numeric(as.character(cjm_byweek_noEU$year))):
                      max(as.numeric(as.character(cjm_byweek_noEU$year))),
               type = "noEU",
               stringsAsFactors = FALSE
               ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_noKOR$fit),
               upr  = exp(pred_noKOR$fit + (1.96 * pred_noKOR$se.fit)), 
               lwr  = exp(pred_noKOR$fit - (1.96 * pred_noKOR$se.fit)),
               year = min(as.numeric(as.character(cjm_byweek_noKOR$year))):
                      max(as.numeric(as.character(cjm_byweek_noKOR$year))),
               type = "noKOR",
               stringsAsFactors = FALSE
               ) ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_noVUT$fit),
               upr  = exp(pred_noVUT$fit + (1.96 * pred_noVUT$se.fit)), 
               lwr  = exp(pred_noVUT$fit - (1.96 * pred_noVUT$se.fit)),
               year = min(as.numeric(as.character(cjm_byweek_noVUT$year))):
                      max(as.numeric(as.character(cjm_byweek_noVUT$year))),
               type = "noVUT",
               stringsAsFactors = FALSE
               ) ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_noRUS$fit),
               upr  = exp(pred_noRUS$fit + (1.96 * pred_noRUS$se.fit)), 
               lwr  = exp(pred_noRUS$fit - (1.96 * pred_noRUS$se.fit)),
               year = min(as.numeric(as.character(cjm_byweek_noRUS$year))):
                      max(as.numeric(as.character(cjm_byweek_noRUS$year))),
               type = "noRUS",
               stringsAsFactors = FALSE
               ) ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_noCHN$fit),
               upr  = exp(pred_noCHN$fit + (1.96 * pred_noCHN$se.fit)), 
               lwr  = exp(pred_noCHN$fit - (1.96 * pred_noCHN$se.fit)),
               year = min(as.numeric(as.character(cjm_byweek_noCHN$year))):
                      max(as.numeric(as.character(cjm_byweek_noCHN$year))),
               type = "noCHN",
               stringsAsFactors = FALSE
               ) ) %>% 
  mutate(year = as.integer(year))


ggplot(df, aes(year)) +
  theme_publication() +
  theme(legend.position  = "none") +
  geom_ribbon(aes(ymin=lwr, ymax=upr, fill=type), alpha=0.2) +
  geom_line(aes(y=cpue, colour=type), size=1) +
  expand_limits(y=0) +
  labs(y="cpue") +
  facet_wrap(~type, scales = "free_y", ncol=2)





```

*`r fig_nums("leaveoneout")`*


<!-- single fleet analysis ------------------------------------------------------ -->

##### page break

**Only single fleet analyses**

The leave-one-out analysis shows that the signal of standardized CPUE is largely similar if data of one of the contracting parties is left out. Notably when the EU data is left out, the pattern and the variance is somewhat different from the other situations. 

```{r echo=FALSE, fig.asp=0.7, fig.align="center", message=FALSE, warning=FALSE}

cjm_byweek_onlyEU  <- filter(cjm_byweek, vesselcp == "EU" )
cjm_byweek_onlyKOR <- filter(cjm_byweek, vesselcp == "KOR" )
cjm_byweek_onlyVUT <- filter(cjm_byweek, vesselcp == "VUT" )
# cjm_byweek_onlyRUS <- filter(cjm_byweek, vesselcp == "RUS" )
cjm_byweek_onlyCHN <- filter(cjm_byweek, vesselcp == "CHN" )

finalMod_onlyEU  <- gam(final,
                      data=cjm_byweek_onlyEU,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_onlyEU)$theta))
finalMod_onlyKOR <- gam(final,
                      data=cjm_byweek_onlyKOR,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_onlyKOR)$theta))
finalMod_onlyVUT <- gam(final,
                      data=cjm_byweek_onlyVUT,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_onlyVUT)$theta))

# finalMod_onlyRUS <- gam(final,
#                       data=cjm_byweek_onlyRUS,
#                       family=negbin(glm.nb(formglm,
#                                            data=cjm_byweek_onlyRUS)$theta))

finalMod_onlyCHN <- gam(final,
                      data=cjm_byweek_onlyCHN,
                      family=negbin(glm.nb(formglm,
                                           data=cjm_byweek_onlyCHN)$theta))

newdat_onlyEU <- expand.grid(
  year        = as.factor(unique(cjm_byweek_onlyEU$year)),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_onlyEU$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_onlyEU$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_onlyEU$year,cjm_byweek_onlyEU$vesselcode2)))))[1],
                         effort=7)

newdat_onlyKOR    <- expand.grid(
  year        = as.factor(unique(cjm_byweek_onlyKOR$year)),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_onlyKOR$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_onlyKOR$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_onlyKOR$year,cjm_byweek_onlyKOR$vesselcode2)))))[1],
                         effort=7)

newdat_onlyVUT    <- expand.grid(
  year        = as.factor(unique(cjm_byweek_onlyVUT$year)),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_onlyVUT$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_onlyVUT$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_onlyVUT$year,cjm_byweek_onlyVUT$vesselcode2)))))[1],
                         effort=7)

# newdat_onlyRUS    <- expand.grid(
#   year        = as.factor(unique(cjm_byweek_onlyRUS$year)),
#   month       = as.factor(3),
#   shootlon    = quantile(cjm_byweek_onlyRUS$shootlon,probs=c(0.5)),
#   shootlat    = quantile(cjm_byweek_onlyRUS$shootlat,probs=c(0.5)),
#   ELE         = as.factor(0),
#   vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_onlyRUS$year,cjm_byweek_onlyRUS$vesselcode2)))))[1],
#                          effort=7)

newdat_onlyCHN    <- expand.grid(
  year        = as.factor(unique(cjm_byweek_onlyCHN$year)),
  month       = as.factor(3),
  shootlon    = quantile(cjm_byweek_onlyCHN$shootlon,probs=c(0.5)),
  shootlat    = quantile(cjm_byweek_onlyCHN$shootlat,probs=c(0.5)),
  ELE         = as.factor(0),
  vesselcode2 = names(rev(sort(colSums(table(cjm_byweek_onlyCHN$year,cjm_byweek_onlyCHN$vesselcode2)))))[1],
                         effort=7)

# calculate the predicted values and confidence intervals
pred_onlyEU       <- predict(finalMod_onlyEU ,newdat_onlyEU,se.fit=T,type="link")
pred_onlyKOR      <- predict(finalMod_onlyKOR,newdat_onlyKOR,se.fit=T,type="link")
pred_onlyVUT      <- predict(finalMod_onlyVUT,newdat_onlyVUT,se.fit=T,type="link")
# pred_onlyRUS      <- predict(finalMod_onlyRUS,newdat_onlyRUS,se.fit=T,type="link")
pred_onlyCHN      <- predict(finalMod_onlyCHN,newdat_onlyCHN,se.fit=T,type="link")

# create df
df    <- data.frame(
               cpue = exp(pred_onlyEU$fit),
               upr  = exp(pred_onlyEU$fit + (1.96 * pred_onlyEU$se.fit)), 
               lwr  = exp(pred_onlyEU$fit - (1.96 * pred_onlyEU$se.fit)),
               year = unique(cjm_byweek_onlyEU$year),
               type = "onlyEU",
               stringsAsFactors = FALSE
               ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_onlyKOR$fit),
               upr  = exp(pred_onlyKOR$fit + (1.96 * pred_onlyKOR$se.fit)), 
               lwr  = exp(pred_onlyKOR$fit - (1.96 * pred_onlyKOR$se.fit)),
               year = unique(cjm_byweek_onlyKOR$year),
               type = "onlyKOR",
               stringsAsFactors = FALSE
               ) ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_onlyVUT$fit),
               upr  = exp(pred_onlyVUT$fit + (1.96 * pred_onlyVUT$se.fit)), 
               lwr  = exp(pred_onlyVUT$fit - (1.96 * pred_onlyVUT$se.fit)),
               year = unique(cjm_byweek_onlyVUT$year),
               type = "onlyVUT",
               stringsAsFactors = FALSE
               ) ) %>% 
  # bind_rows(., data.frame(
  #              cpue = exp(pred_onlyRUS$fit),
  #              upr  = exp(pred_onlyRUS$fit + (1.96 * pred_onlyRUS$se.fit)), 
  #              lwr  = exp(pred_onlyRUS$fit - (1.96 * pred_onlyRUS$se.fit)),
  #              year = unique(cjm_byweek_onlyRUS$year),
  #              type = "onlyRUS",
  #              stringsAsFactors = FALSE
  #              ) ) %>% 
  bind_rows(., data.frame(
               cpue = exp(pred_onlyCHN$fit),
               upr  = exp(pred_onlyCHN$fit + (1.96 * pred_onlyCHN$se.fit)), 
               lwr  = exp(pred_onlyCHN$fit - (1.96 * pred_onlyCHN$se.fit)),
               year = unique(cjm_byweek_onlyCHN$year),
               type = "onlyCHN",
               stringsAsFactors = FALSE
               ) ) %>% 
  mutate(year = as.numeric(as.character(year)))


ggplot(df, aes(year)) +
  theme_publication() +
  theme(legend.position  = "none") +
  geom_ribbon(aes(ymin=lwr, ymax=upr, fill=type), alpha=0.2) +
  geom_line(aes(y=cpue, colour=type), size=1) +
  geom_point(aes(y=cpue, colour=type), size=1.5) +
  expand_limits(y=0) +
  labs(y="cpue") +
  facet_wrap(~type, scales = "free_y", ncol=2)



```

<!--4. Discussion and conclusions ------------------------------------------------------ -->

# Discussion and conclusions

This working document describes the work aimed to standardizing all the CPUE data from the offshore fleets (China, EU, Korea, vanuatu and Russia) based on the haul-by-haul data contained in the SPRFMO database. Permission to utilize that information was granted by the delegations of the contracting parties while the analysis was carried out by scientists from the EU delegation. 

The final model for standardizing the CPUE of these fleets models the catch by week and takes into account of the vessel, month, and a smooth interaction between latitude and longitude  with an offset of log effort (in number of days per week). The new standardized CPUE series starts in 2008 as this is the first year for which haul by haul information was available to carry out this analysis. It is recommended to extend the time-series, where possible, to the years before 2008, in order to get more information on the catch rates during the higher abundances of jack mackerel.    

A 'leave-one-out analysis' was carried out by removing the data of one of the contracting parties from the analysis to explore the sensitivity of the results to the data being used. The conclusion from that analysis is that, by and large, the trends are similar. Likewise, the "single-fleet-analysis" indicates that the analysis based on one single fleet at a time, generates comparable trends over time.    


<!--5. Acknowledgements ------------------------------------------------------ -->

# Acknowledgements

We would like to acknowledge the permission granted by the delegations of China, Russia, Vanuatu and Korea to utilize their haul-by-haul data for the analysis of standardized CPUE of the offshore fleet fishing for Jack mackerel. Sharing access to vessel data has made it possible to improve the indicator that can be used in the assessment. 

<!--6. References ------------------------------------------------------ -->

# References

Li, G., X. Zou, X. Chen, Y. Zhou and M. Zhang (2013). "Standardization of CPUE for Chilean jack mackerel (Trachurus murphyi) from Chinese trawl fleets in the high seas of the Southeast Pacific Ocean." Journal of Ocean University of China 12(3): 441-451.

SPRFMO (2011) Report of the Jack Mackerel Subgroup. Tenth Science Working Group of SPRFMO, 19 – 23 September 2011, Port Vila, Vanuatu.

SPRFMO (2018) CPUE standardization for the offshore fleet fishing for Jack mackerel in the SPRFMO area (SCW6-Doc05). Sixth Science Committee Workshop, 28-30 May 2018, Valparaiso, Chile.

